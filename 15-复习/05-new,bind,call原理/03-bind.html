<script>
// ------------------------------------- bind 基本使用
// bind 也可以让obj去借用f
// 和call一样，bind也可以改变this的指向
// 和call不一样，bind返回一个绑定后的函数
// function f(){
//     console.log("f....")
//     console.log(this)
// }
// let obj = {name:"wangcai"}

// let newF = f.bind(obj)
// newF()

// ---------------------- bind的原理 借助了call或apply
// function f(){
//     console.log("f....")
//     console.log(this)
// }
// let obj = {name:"wangcai"}
// Function.prototype.bind = function(context){
//     // this 是 f  
//     let that = this;  
//     return function(){
//         // console.log(this)  // Window 
//         // console.log(that)  // f  是一个函数
//        return that.call(context)  // context 是 obj 
//     }
// }
// let newF = f.bind(obj)
// newF()

//  ------------------------------ bind 传参问题  bind里面的参数
// function f(name,age,n,a){
//     console.log(name,age,n,a)
//     console.log(this)
// }
// let obj = {name:"wangcai"}
// Function.prototype.bind = function(context){
//     let that = this;  
//     // arguments 伪数组   真实数组
//     // arguments上面的没有slice，我要借用slice 
//     let newArr = Array.prototype.slice.call(arguments,1);
//     return function(){
//        return that.apply(context,newArr)  // context 是 obj 
//     }
// }
// let newF = f.bind(obj,"hello","world","lalala")  // hello
// newF("xxxx")

// ---------------------- bind原理 传递问题
// function f(name,age,n,a){
//     console.log(name,age,n,a)
//     console.log(this)
// }
// let obj = {name:"wangcai"}
// Function.prototype.bind = function(context){
//     let that = this;  
//     let newArr = Array.prototype.slice.call(arguments,1);
//     return function(){
//        let newArr2 = Array.prototype.slice.call(arguments)
//        // that 是 f  
//        return that.apply(context,newArr.concat(newArr2))  
//     }
// }
// let newF = f.bind(obj,"hello","world","lalala")  
// newF("xxxx")

// ---------------------  绑定this之后的函数还可以被new
// function f(){
//     console.dir(this)
// }
// let obj = {name:"wangcai"}
// let bindF = f.bind(obj)  
// // bindF() // {name: "wangcai"}

// // 如果绑定的函数被new了，new出来的是对象
// // this就指向这个对象 ，this就指向instance
// let instance = new bindF()  








</script>