JavaScript是一门运行在浏览器端的脚本语言。

JS的运行环境：
    浏览器
    node
    手机
    嵌入式
    ai 
    区块链

Java和JavaScript：
    没有关系    如果非要从商业角度来说，JavaScript是借住Java火起来。

JAVAScript包含如下几个部分：
    ECMAScript  欧洲计算机制造联合会  标准  规定常用的语法
    BOM  Brower Object Model 
    DOM  Document Object Model
    先学习ES

JS写法：
    行内（内联）
    内部  <script>  </script>  内部写法
    外部  <script src="./out.js"></script>


--------- 变量  
进程：当一个项目运行起来后，就是一个进程   工厂
     进程是操作系统分配和调试资源（cpu和内存）的基本单位

线程：真正干活是线程   js是单线程（就一个工人）   工人
     默认情况下，工人从上向下干活（执行任务）
     JS是单线程的，是指它的主线程是单线程。如果主线程遇到一个非常耗时的任务，它就找别的线程来帮忙。别的线程把活干完后，需要把结果给主线程。
    非常耗时的任务：网络请求数据  读取文件操作 ...... 

变量：
    开发软件的目的--->处理数据  
    数据怎么保存---> 内存（小格子）
    使用数据--->每个小格子有一个地址，根据这个地址，找到小格式
    使用指针非常麻烦--->变量 把每一个小格子起一个别名  这个别名就是变量名
    变量 = 变量名 +　变量值

声明一个变量：后面不会使用var来声明变量（重复声明，遗漏声明，提升）
    一次声明一个变量   var name = "z3";  var age = 12;
    一次声明多个变量   var a, b, c;
    重复声明
    遗漏声明

全局变量 和 局部变量（普通话和方言）：
    分界点：函数   声明变量使用var  声明函数用function
    全局变量在函数内外都可以访问
    局部变量只能在函数内可以访问，函数外不能访问

数据类型:
    针对不同的数据，分配不同的内存空间---->为了合理使用内存空间。
    两类：
        基本数据类型：
            nubmer,string,boolean,undefiend,null
        引用数据类型：
            object(array,function)

JS代码的解析与执行：
    1，代码块可以有多个，上面的代码块不能使用下面的代码块中的数据，下面代码块可以使用上面代码块中的数据。
    2，预编译，在Js代码真正执行这前有一个预编译的过程
        提升：
            提升变量: 提升代码块的最前面
            提升函数：
        执行：
    3，变量提升
        var变量可以提升,没有var的变量是不会提升的
        循环变量也可以提升
        函数内部加var的变量也会提升，提升到了函数内部的最前面
    4，提升函数
        函数声明也会提升，提升到代码块的最前面
        函数表达式不会提升，原因函数表达式本质是一个变量

数据的存储：
两类：
    基本数据类型：栈区
        nubmer,string,boolean,undefiend,null
        对于基本数据类型的赋值var b = a; 是把a中栈区中的数据取出来一份，给了b，a和b是独立。
    引用数据类型：堆区
        object(array,function)

声明和定义：
    var a;  // 声明变量 
    var a = 1; // 如果在声明变量的同时给这个变量赋值了，叫定义

ES6中定义变量，使用let const：

let:
    与var类似，用来定义变量
    特点：
        块级作用域(第三种作用域)。let所声明的变量，只在let命令所在的代码块内有效。
            在使用var的时代，只有全局作用域和局部作用域，在es6中提出let关键，可以声明一个块级作用域。
        let没有“变量提升”现象。
        不会成为window对象的属性
        暂时性死区（TDZ）
        不能重复定义
const:
    const：声明常量。值不能改变。
    特点： 
        1，定义完后，不能修改值(基本数据类型，也可能是地址)
        2，不能重复声明
        3，没有提升
        4，声明时必须赋值
------------
语句：
    循环语句
        for循环
        while循环 
        do...while循环
    条件语句

总结：
    1，js  行内  内部   外部
    2，变量 
        var let const 
        var:重复声明，遗漏声明，没有块级作用域，提升
        let：声明变量
        const:声明常用
    3，js代码的解析与执行
        解析：预编译
            提升变量声明  提升函数声明
        执行： 
            js是单线程  从上到下挨个执行任务
    4，js中变量的存储
        基本数据类型存储在栈区
        引用数据类型存储在堆区
    5，语句 
        for循环
            打印1~100的和
            百钱买百鸡
            九九乘法--表冒泡排序

----------------- 函数 封装功能块

数学中的函数     y = x^2   本质就是一个规则（功能块）  给这个功能块输入一些东西，这个功能块就会给我们输出一些东西
在JS中，函数肯定会我们输出东西，可以不给它输入东西。

在JS中，它内部有很多内置的函数，我们可以直接使用，我们也可以自定义函数。 alert()

函数定义：
    函数声明
        function f(参数1){}  function用来声明函数   f函数名   ()是函数的特殊标志   {}函数体

    函数表达式（变量）

函数调用：
    如果定义好一个函数，需要调用它，它才会执行函数体中的代码，如果没有调用，相当于函数没有写

函数的参数：
    形参：
        函数定义时，()中写的参数，叫形参，相当于函数内部的局部变量，作用是用来接收实参
    实参：
        函数调用时，()中写的参数，叫实参，作用是给函数传递真实的数据，传递过去形参接收了。


函数的返回值：
    通过return返回，返回到函数的调用处。
    在函数体中，return后面的代码就不会执行了。return也叫跳转语句。

命名法：
    小驼峰命名：toString()
    大驼峰命名：ToString()
    下划线命名：to_string()

作用域:
    在JS中，作用域分三类：全局作用域，局部作用域，函数内部会形成一个局部作用域（函数作用域），块级作用域（let{}）

参数的传递：
    基本数据类型的数据（值传递）
        就是把栈区的数据copy一份给了形参，形参和实参是一个独立一个内存空间。
        改变形参，实参是没有影响。 
    引用数据类型的数据（引用传递）
        就是把栈栈区的地址copy一份给了形参，形参和实参同时指向堆区同一个内存空间。
        通过形参改变堆区内存空间的数据，实参这个地址应对的数据也会发生改变。

函数可以作为另一个函数的参数：
    一个函数可以作为另一个函数的参数，这个函数可以是函数声明，也可以是函数表达式
    在JS，我们可以把一个函数声明，作为别一个函数的参数

arguments:
    函数调用的过程就是实参向形参赋值的过程。实参会复制一份给形参。
    除了复制一份给形参外，它会给arguments一份。
    arguments中收集了实参。 
    arguments只是函数内部的属性（类数组）， 在函数外面是不能访问的。
    arguments和形参这间有一一对应的关系：
        当形参改变了，那么arguments里面的数据也会改变
        当改变了arguments里面的数据，形参也会发生改变
    什么时候使用形参，什么时候使用arguments？
        1，当实参非常多时，写一堆的形参来接收，不方便，此时你就可以使用arguments
        2，当实参有特殊含义时，需要有一个特殊的标识，就可以使用形参来标识

JS有两个容器：
    数组：[1,2,3,"hello",true]   获取某个元素，使用索引
    对象：{name:"wangcai",age:100}  name和age叫key   wangcai和100叫value

函数返回多个值:
    默认情况下，Js函数只能返回一个值。
    如果你想返回多个值的话，那么你可以使用容器。

总结： 
    1，函数的作用：封装成功能块，用的时候直接调用
    2，函数定义：函数声明   函数表达式
    3，函数调用：函数定义完后，没有调用，相当于没有写
                函数调用的过程就是实参向形参赋值的过程。
    4，函数的返回值：return 如果没有写返回值，默认返回undefined
    5，函数的参数：形参（函数定义时()里面的参数）和实参 (函数调用时()里面的参数)
    6，值传递，引用传递
    7，函数可以作为另一个函数的参数  setTimeout(function(){},3000)
    8，arguments  收集实参 
    9，返回要想返回多个值，你需要返回一个容器（数组，对象）

----------------- 复习函数
1，定义函数    function f(){}     var g = function(){}
2，函数参数    形参和实参
3，函数调用    f()   函数调用的过程就是实参向形参赋值的过程
4，函数返回值  return   
5，值传递和引用传递  画图
6，arguments 收集实参 
7，函数要返回多个值，可以把多个值放到一个容器中，数组  对象 

---------------- ES6中对函数的扩展 
参数的默认值：
    1，参数默认值  当我们没有给形参传值时，使用默认值，如果给形参传值，使用我们传递的值。
    2，传递赋值时，实参的第1个会赋给形参的第1个，依次向后..
    3，如果实参个数多于形参个数，后面的实参忽略了。
    4，如果形参个数多于实参个数，后面的形参的值是undefined。

扩展运算符：
    ... 

rest参数：...rest 在函数定义时的形参的位置写的...
    代替arguments
    定义函数时…

箭头函数:
    function f(){}     var g = function(){}
    特点1：只有一个形参时，()可不写
    特点2：只有一个带return语句   {} 和 return 都可以不写
    特点3：只有一个不带return语句  {} 可以不写
    特点4：如果返回对象，把{} 和 return 省掉的话，需要给这个对象加()

    在箭头函数中没有argumetns，可以使用rest参数 
    在箭头函数中没有this

------------------ 执行上下文 
全局代码，函数代码：
    局部代码：在函数里面的代码叫局部代码。
    全局代码：默认进入的就是全局代码 

全局执行上下文，函数局部代码：
    当执行全局代码时，产生一个全局执行上下文。
        全局执行上下文只有一个。
    当执行函数代码时，产生一个函数执行上下文。
        每调用一次函数，都会产生一个函数的执行上下文件。函数执行上下文可以有N个。

执行上下文栈：
    全局执行上下文位于栈底，当调用一个函数，就产生一个局部地执行上下文，这个局部地执行上下文
    要压栈，当这个函数执行完，这个执行上下文就要出栈。

执行上下文的作用：   
    给全局代码或局部代码提供数据。数据包含变量和函数。

父级函数：

全局执行上下文中组成如下：
    1，全局地变量和函数 

局部执行上下文中组成如下：
    1，本函数内部的变量，arguments，内部定义的函数
    2，父级函数的执行上下文

为什么函数内部的变量，在函数的外部无法访问，从执行上下文的角度来分析：

-------- 函数复习
    1，定义函数 调用函数 函数参数 函数的返回值 
    2，arguments  ---> 收集实参 
    3，es6中对函数进行扩展 ---> 参数的默认值  ...rest   =>
    4，执行上下文--->作用给代码提供数据（变量和函数）
    5，全局执行上下文，局部执行上下文，执行上下文栈

作用域链：
    作用域链是一种数据的查找机制，要搞清楚作用域链，你需要知道执行上下文。

把一个函数定义到另一个函数的内部：
    某些函数，不想让别人直接访问，就可以把这个函数定义到另一个函数的内部，达到封装效果。

函数还可以作为返回值：
    函数在js中也是一种数据类型，引用数据类型。引用数据类型：[]   {}   函数 

立即执行的函数表达式IIFE:
    不需要我们手动地调用就可以执行的函数。
    实现：()把整体包起来   ()把函数声明包起来   + -  *  /  !
    IIFE最好在最后面加上;

闭包：
    如果在一个函数中，又嵌套了一个函数，并且里面这个函数引用外面的函数的变量。
    当一个函数调用完毕后，它里面的变量所占的空间会被释放
    闭包可以延长变量的生命周期
    闭包可以产生内存泄露





